------------------------------------------------
------------------------------------------------
Curso Docker Platzi
------------------------------------------------
------------------------------------------------

Docker
  Estandar para desarrollar, distribuir y ejecutar aplicaciones a nivel productivo

Por que?
  compatibilidad del software en los ambientes de desarrollo y produccion
  genera confianza, desplegar en otros entornos
  

*** LAS TRES AREAS EN EL DESARROLLO DE SOFTWARE PROFESIONAL ***
  
  1. construir
  
    escribir codigo es una peque√±a parte
    los problemas complejos necesitan equipos
      --> entornos de desarrollo
      --> dependencias
      --> entonrno de ejecucion
      --> equivalenias con entorno productivo
      --> servicios externos
    
  2. distribuir
  
    tu codigo tiene que transformarse en un artefacto o varios que puedan ser transformados
    a donde tenga que ser ejecutados
      --> divergencia de repositorios
      --> divergencia de artefactos
      --> versionado
      
  3. ejecutar
  
    la maquina donde se escribe el softare siempre es distinta a la maquina donde se ejecuta de manera productiva
      --> compatibilidad con el entorno productivo
      --> dependencias
      --> disponibilidad de servicios externos
      --> recursos de hardware
 

Aportes de la clase

Resumen de la clase:

‚ÄúDocker te permite construir, distribuir y ejecutar cualquier aplicaci√≥n en cualquier lado.‚Äù

Problem√°ticas del desarrollo de software
1. Construir - Escribir c√≥digo en la m√°quina del desarrollador. (Compile, que no compile, arreglar el bug, compartir c√≥digo, etc. )

Problem√°tica:
  Entorno de desarrollo (paquetes)
  Dependencias (Frameworks, bibliotecas)
  Versiones de entornos de ejecuci√≥n (runtime, versi√≥n Node)
  Equivalencia de entornos de desarrollo (compartir el c√≥digo)
  Equivalencia con entornos productivos (pasar a producci√≥n)
  Servicios externos (integraci√≥n con otros servicios ejem: base de datos)
  
2. Distribuir - Llevar la aplicaci√≥n donde se va a desplegar (Transformarse en un artefacto)

Problem√°tica:
  Output de build heterogeo (m√∫ltiples compilaciones)
  Acceso a servidores productivos (No tenemos acceso al servidor)
  Ejecuci√≥n nativa vs virtualizada
  Entornos Serverless

3. Ejecutar - Implementar la soluci√≥n en el ambiente de producci√≥n (Subir a producci√≥n)
  El reto Hacer que funcione como deber√≠a funcionar

Problem√°tica:
  Dependencia de aplicaci√≥n (paquetes, runtime)
  Compatibilidad con el entorno productivo (sistema operativo poco amigable con la soluci√≥n)
  Disponibilidad de servicios externos (Acceso a los servicios externos)
  Recursos de hardware (Capacidad de ejecuci√≥n - Menos memoria, procesador m√°s debil)
      


***  VIRTUALIZACION ***

version virtual de algun recurso tecnologico como (...) hardware, un sistema operativo, un dispositivo de almacenamiento o recurso de red
  
  permite atacar en simulateno os tres problemas del desarrollo de software profesional

Maquinas virtuales

  Problemas de las VMs
  
    Peso
      --> en el orden de los GB repiten archivos comunes, inicio lento

    Costos de administracion
      --> necesita mantenimiento igual que cualquier otra computadora
      
    Multiples de formatos
      --> VDI, VMDK, VHD, raw entre otras
      
para solucionar el tema de las maquinas virtuales se crearon los Contenedores

  Objetivo
    el empleo de contenedores para contruir y desplegar software
      --> flexibles
      --> livianos
      --> portables
      --> Bajo acoplamiento
      --> Escalables
      --> Seguros
  
Aporte de la clase

Un contenedor la unidad logica mas importande de docker que permite encapsular las dependencias de un proyecto en un entorno aislado, 
y pas√°rsela a tus compa√±eros o colocarlo en un servidor para el despliegue de manera f√°cil.

¬°Alerta! Puedes ver a un contendor como una maquina virtual pero eso no significa que lo sea, una maquina virtual puede llegar a se muy similar debido a sus funcionalidades 
como el aislamiento de procesos.

Entonces‚Ä¶ ¬øcu√°l es el beneficio de usar contenedores en lugar de maquinas virtuales?

El mayor beneficio es que los contenedores de Docker est√°n en el nivel de los MB eso nos da ventajas en el consumo de recursos, ya que estos corren compartiendo el host del 
kernel de Linux, por otro lado las maquinas virtuales son un sistema operativo(O.S) con sus propias apps que corre sobre el tuyo usando virtualizacion y que consume muchos 
recursos en el nivel de los GB. Una mejor forma de ver esto es observando la arquitectura de los contendores y de las maquinas virtuales



*** PREPARANDO TU ENTORNO DE TRABAJO ***

pagina web --> docker.com
  Doccker desktop
  Docker Hub
  Play with Docker
  
para maquinas windows menores a 10
  --> https://github.com/docker/toolbox/releases
windows 10
  --> 
  
aportes de la clase

Puedes seguir las gu√≠as de instalaci√≥n de docker en linux dependiendo de tu distribuci√≥n.
  Cent OS: https://docs.docker.com/engine/install/centos/
  Debian: https://docs.docker.com/engine/install/debian/
  Fedora: https://docs.docker.com/engine/install/fedora/
  Ubuntu: https://docs.docker.com/engine/install/ubuntu/



*** PRIMEROS PASOS DE CONTENEDOR - HOLA MUNDO ***

--> comando
  docker run <nombre del contenedor a crear>
    --> ejemplo docker run hello-world

aportes de la clase

- Levantando contenedores
üîπ Arrancar un contenedor.

docker run <image_container>
Ejemplo:

docker run hello-world
üîπ Arrancar un contenedor asign√°ndole un nombre.

docker run --name <name_container> <image_container>
Ejemplo:

docker run --name contenedor_test ubuntu
üîπ Arrancar un contenedor con una terminal interactiva. Pas√°ndole una shell para acceder al contenedor.

docker run -it <image_container> <shell>
Ejemplo:

docker run -it ubuntu bash
üîπ Arrancar un contenedor. Mapeando un puerto del host a un puerto del contenedor.

puerto_host : puerto_contenedor
docker run -p <host_port>:<container_port> <image_container>
Ejemplo:

docker run -p 8080:80 nginx
Igual que el ejemplo anterior pero dej√°ndolo en segundo plano.

docker run -p 8080:80 -d nginx
üîπ Arrancar un contenedor. Que tras terminar su periodo de vida. Ser√° eliminado autom√°ticamente.

docker run --rm <image_container>
Ejemplo:

docker run -p 8080:80 -d --rm nginx
üîπ Arrancar un contenedor con un volume.

docker run -v <volume_name>:<mount_point>:<options> <image_container>
Ejemplo:

Volume -> test
Punto de montaje en el contenedor -> /apps
Opciones -> rw (Lectura y escritura)
docker run -v test:/apps:rw nginx
üîπ Arrancar un contenedor con un bind mount.

docker run -v <shared_folder>:<mount_point>:<options> <image_container>
Ejemplo:

Ruta del host a compartir -> /home/application
Punto de montaje en el contenedor -> /apps
Opciones -> ro (Solo lectura)
docker run -v /home/application:/apps:ro ubuntu
üîπ Arrancar un contenedor con tmpfs.

docker run \
--mount type=tmpfs,destination=<mount_point>,tmpfs-mode=<permisos>,tmpfs-size=<bytes_size> \
<image_container>
Ejemplo:

Punto de montaje en el contenedor -> /temporal
Permisos -> Todos los permisos solo para el propietario.
Tama√±o del FS -> 21474836480 bytes = 20G
docker run \
--mount type=tmpfs,destination=/temporal,tmpfs-mode=700,tmpfs-size=21474836480 \
nginx
- Listando contenedores
üîπ Lista de los contenedores activos.

docker ps
üîπ Lista de todos los contenedores activos e inactivos del sistema.

docker ps -a
üîπ Lista los ID de todos los contenedores.

docker ps -aq
- Debugging
üîπ Inspeccionar la data de un contenedor.

Por su ID:
docker inspect <id_container>
Por su nombre:
docker inspect <name_container>
Aplicando filtros. Por ejemplo buscando las variables de entorno:
docker inspect -f '{{ json .Config.Env }}' <name_container>
üîπ Ver los logs del contenedor.

docker logs <name_container>
- Eliminando contenedores
üîπ Eliminar un contenedor que no este arriba.

Se puede hacer tanto por nombre como por ID.
docker rm <name_container>
üîπ Eliminar un contenedor aunque este arriba. Forz√°ndolo.

Se puede hacer tanto por nombre como por ID.
docker rm -f <id_container>
üîπ Eliminar todos los contenedores que no esten arriba a la vez.

docker rm $(docker ps -aq)
   


*** CONCEPTO FUNDAMENTALES DE DOCKER - CONTENEDORES ***

Docker es una herramienta de codigo abierto que nos sirve para desarrollar, enviar y ejecutar
aplicaciones en contenedores

que son los contenedores?
  son unidades logicas computadas por un conjunto de procesos
  los contenedores surgieron con la union de varias tecnologias como
    namespaces
    cgroups
    chroot

Docker por dentro

mediante el cliente podremos enviar comandos al docker deamon para interactuar con los contenedors
  docker deamon recibe los comandos y envia ordenes a los contenedores para indicarles como y que deben ejecutar

contenedores
  ejecutan los proceso indicados por el docker deamon
  estos procesos viven en el contenedor y mueren con el contenedor, esto hace que se mantengan
  asilados de los proceso que se mantengan aislados de los procesos que corren en el sistma operativo del host

aunque puedes usar Docker tanto en windows como MacOs. este solo corre nativamente en Linux


Por que usar Docker?

  "en mi equipo la app corria correctamente"
  evita fallos gracias a que podras tener entornos de desarrollo y de produccion practicamente iguales
  
  "Evita problemas con las versiones"
  en cada contenedor podras correr lo que necesites
  
  "Distribuye y comparte facilmente"
  una de las grandes ventajas de los contenedores es su peque√±o tama√±o. imagina tener un Linuz en tan solo 5MB con Docker es posible
  

Que es un contenedor ?

  Es una agrupaci√≥n de procesos.
  Es una entidad l√≥gica, no tiene el limite estricto de las m√°quinas virtuales, emulaci√≥n del sistema operativo simulado por otra m√°s abajo.
  Ejecuta sus procesos de forma nativa.
  Los procesos que se ejecutan adentro de los contenedores ven su universo como el contenedor lo define, no pueden ver mas all√° del contenedor, a pesar de estar corriendo en una maquina m√°s grande.
  No tienen forma de consumir m√°s recursos que los que se les permite. Si esta restringido en memoria ram por ejemplo, es la √∫nica que pueden usar.
  A fines pr√°cticos los podemos imaginar c√≥mo maquinas virtuales, pero NO lo son. M√°quinas virtuales livianas.
  Docker corre de forma nativa solo en Linux.
  Sector del disco: Cuando un contenedor es ejecutado, el daemon de docker le dice, a partir de ac√° para arriba este disco es tuyo, pero no puedes subir mas arriba.
  Docker hace que los procesos adentro de un contenedor este aislados del resto del sistema, no le permite ver m√°s all√°.
  Cada contenedor tiene un ID √∫nico, tambi√©n tiene un nombre.



*** COMPRENDIENDO DOCKER ***

Comandos:

  $ docker run hello-world (corro el contenedor hello-world)
  $ docker ps (muestra los contenedores activos)
  $ docker ps -a (muestra todos los contenedores)
  $ docker inspect <containe ID> (muestra el detalle completo de un contenedor)
  $ docker inspect <name> (igual que el anterior pero invocado con el nombre)
  $ docker run ‚Äì-name hello-platzi hello-world (le asigno un nombre custom ‚Äúhello-platzi‚Äù)
  $ docker rename hello-platzi hola-platzy (cambio el nombre de hello-platzi a hola-platzi)
  $ docker rm <ID o nombre> (borro un contenedor)
  $ docker container prune (borro todos lo contenedores que esten parados)



*** EL MODO INTERACTIVO - CORRER UN LINUX UBUNTU CON DOCKER  ***

comando
--> docker run ubuntu
--> docker run -it ubuntu  (el comando it significa iterativo, podemos entrar a la maquina de ubuntu y navegar entre sus archivos)

Comandos:
$ docker run ubuntu (corre un ubuntu pero lo deja apagado)
$ docker ps -a (lista todos los contenedores)
$ docker -it ubuntu (lo corre y entro al shell de ubuntu)
-i: interactivo
-t: abre la consola
  --> cat /etc/lsb-release (veo la versi√≥n de Linux)


With an Existing container

1. start the container
    --> docker start id-container
2. execute interactively bash in the container
    --> docker exec -it id-container bash 



*** CICLO DE VIDA DE UN CONTENEDOR  ***

comando
  --> $ docker run --name alwaysup -d ubuntu tail -f /dev/null
  
  observaciones
    se pueden usar al final del tail -f las siguientes instrucciones para que no se apague el contenedor
      /dev/full
      /dev/zero
      /dev/random
      
  --> $ docker exec -it alwaysup bash
  
  --> $ docker inspect --format '{{.State.Pid}}' alwaysup
      --> 3744
      --> $ kill 3744
          bash: kill: (3744) - No such process (no corre en windows)
      
          Para detener procesos en windows usamos el siguiente comando
          --> $ docker stop alwaysup



***  EXPONIENDO CONTENEDORES ***

Comandos:

$ docker run -d --name proxy nginx (corro un nginx)
$ docker stop proxy (apaga el contenedor)
$ docker rm proxy (borro el contenedor)
$ docker rm -f <contenedor> (lo para y lo borra)

$ docker run -d --name proxy -p 8080:80 nginx (corro un nginx y expongo el puerto 80 del contenedor en el puerto 8080 de mi m√°quina)
  --> docker run -d --name [name] -p [HostPort/8080]:[ContainerPort/80] [imagen/nginx]

localhost:8080 (desde mi navegador compruebo que funcione)
$ docker logs proxy (veo los logs)
$ docker logs -f proxy (hago un follow del log)
$ docker logs --tail 10 -f proxy (veo y sigo solo las 10 √∫ltimas entradas del log)



*** BIND MOUNTS  ***

Todo lo que se ve en esta clase est√° relacionado con vol√∫menes y como ya se dijo en clases anteriores Docker es virtualizaci√≥n de sistemas encontramos 
tambi√©n vol√∫menes que son algo as√≠ como discos duros o datos que los contenedores pueden usar

Hay varios tipos de vol√∫menes

--> Container --> (bind mount)  --> filesystem 
              --> (Volume)      --> [docker area] 
              --> tmpfs mount   ----------------------> Memory

Para diferentes usos pero siempre se usan para persistir datos como por ejemplo imagina que est√°s haciendo una app que usa postgres sin importar 
la tecnolog√≠a que usas para la l√≥gica (node, python, php, java, c#) puedes tener muchas instancias de postgres en muchas versiones y los datos no se perder√°n 
a menos que los elimines

--> https://docs.docker.com/storage/volumes/

Para W10
usar√© este tutorial para lo que me comentaste sobre WSL2:
https://platzi.com/tutoriales/1650-prework/5895-aprende-a-instalar-wsl-2-de-la-manera-sencilla/
y luego har√© lo que me comentas üòÉ

Comandos:

$ mkdir dockerdata (creo un directorio en mi m√°quina)
$ docker run -d --name db mongo
$ docker ps (veo los contenedores activos)
$ docker exec -it db bash (entro al bash del contenedor)
$ mongo (me conecto a la BBDD)

    shows dbs (listo las BBDD)
    use platzi ( creo la BBDD platzi)
    db.users.insert({"nombre":"walther"}) (inserto un nuevo dato)
    db.users.find() (veo el dato que cargu√©)
    $ docker run -d --name db -v <path de mi maquina>:<path dentro del contenedor(/data/db mongo)> (corro un contenedor de mongo y creo un bind mount)



*** VOLUMENES  ***

Manera mas estandar en manejar la informacion de los dockers
Fueron una evolucion para manejar datos, 
mejora la seguridad de la informacion cuando se guarda los datos en disco
solo los volumenes pueden acceder a los datos creados desde esta opcion
por bind-mount cualquiera con acceso al disco podria manipular los datos

Comandos volumenes

--> docker volume ls (lista todos los volumenes creados)
--> docker volume create [nombre de la bd]
--> docker run -d --name db --mount src=dbdata,dst=/data/db mongo (ruta destino donde mongo db guarda su bd)



*** INSERTS Y EXTRAER ARCHIVOS DE UN CONTENEDOR  ***

Comandos:

$ touch prueba.txt (creo un archivo en mi m√°quina)
$ docker run -d --name copytest ubuntu tail -f /dev/null (corron un ubuntu y le agrego el tail para que quede activo)
$ docker exec -it copytest bash (entro al contenedor)
$ mkdir testing (creo un directorio en el contenedor)
$ docker cp prueba.txt copytest:/testing/test.txt (copio el archivo dentro del contenedor)
$ docker cp copytest:/testing localtesting (copio el directorio de un contenedor a mi m√°quina)
con ‚Äúdocker cp‚Äù no hace falta que el contenedor est√© corriendo



